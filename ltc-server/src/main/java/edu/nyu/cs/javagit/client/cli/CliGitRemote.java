/*
 * ====================================================================
 * Copyright (c) 2008 JavaGit Project.  All rights reserved.
 *
 * This software is licensed using the GNU LGPL v2.1 license.  A copy
 * of the license is included with the distribution of this source
 * code in the LICENSE.txt file.  The text of the license can also
 * be obtained at:
 *
 *   http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
 *
 * For more information on the JavaGit project, see:
 *
 *   http://www.javagit.com
 * ====================================================================
 */
package edu.nyu.cs.javagit.client.cli;

import edu.nyu.cs.javagit.api.JavaGitConfiguration;
import edu.nyu.cs.javagit.api.JavaGitException;
import edu.nyu.cs.javagit.api.commands.IGitRemote;
import edu.nyu.cs.javagit.api.options.GitRemoteOptions;
import edu.nyu.cs.javagit.api.responses.GitRemoteResponse;
import edu.nyu.cs.javagit.utilities.CheckUtilities;

import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Command-line implementation of the <code>IGitRemote</code> interface.
 */
public class CliGitRemote implements IGitRemote {

    // patterns to match parsed lines against:
    // ---------------------------------------
    //  "spartan	linda@spartan:github/independence.git (fetch)"
    //  "spartan	linda@spartan:github/independence.git (push)"
    private final static Pattern REMOTE_PATTERN = Pattern.compile("^\\s*(\\S+)\\s+(\\S+)\\s+\\((fetch|push)\\)");

    @Override
    public int add(File repositoryPath, GitRemoteOptions options, String name, String url) throws JavaGitException {
        CheckUtilities.checkFileValidity(repositoryPath);
        CheckUtilities.checkStringArgument(name, "name of remote");
        CheckUtilities.checkStringArgument(url, "url of remote");

        return ProcessUtilities.runCommand(repositoryPath,
                buildCommand(options, "add", name, url),
                new GitRemoteParser(new GitRemoteResponse())).getExitCode();
    }

    @Override
    public int rm(File repositoryPath, GitRemoteOptions options, String name) throws JavaGitException {
        CheckUtilities.checkFileValidity(repositoryPath);
        CheckUtilities.checkStringArgument(name, "name of remote");

        return ProcessUtilities.runCommand(repositoryPath,
                buildCommand(options, "rm", name),
                new GitRemoteParser(new GitRemoteResponse())).getExitCode();
    }

    @Override
    public Set<GitRemoteResponse.Remote> remote(File repositoryPath) throws JavaGitException {
        CheckUtilities.checkFileValidity(repositoryPath);

        GitRemoteResponse response = ProcessUtilities.runCommand(repositoryPath,
                buildCommand(new GitRemoteOptions(true), null, (String[]) null),
                new GitRemoteParser(new GitRemoteResponse()));
        if (response.isError())
            throw new JavaGitException("Git remote error: " + response.getError());
        return response.getRemotes();
    }

    private List<String> buildCommand(GitRemoteOptions options, String subcommand, String... parameters) {
        List<String> command = new ArrayList<String>();
        command.add(JavaGitConfiguration.getGitCommand());
        command.add("remote");

        // verbose option must come before subcommand
        if (options != null && options.verbose)
            command.add("-v");

        if (subcommand != null)
            command.add(subcommand);

        if (options != null) {
            // TODO: implement if more options are supported
        }

        if (parameters != null)
            command.addAll(Arrays.asList(parameters));

        return command;
    }

    /**
     * Parser class to parse the output generated by git remote; and return a
     * <code>GitRemoteResponse</code> object.
     */
    private class GitRemoteParser extends AbstractParser<GitRemoteResponse> {

        private GitRemoteParser(GitRemoteResponse response) {
            super(response);
        }

        @Override
        public void parseLine(String line, String lineending) {
            if ("".equals(line))
                return;

            // catch error output first:
            if (response.isError() || line.trim().startsWith("fatal:") || line.trim().startsWith("error:")) {
                response.addError(line);
                return;
            }

            // try matching various line formats
            Matcher m;

            if ((m = REMOTE_PATTERN.matcher(line)).matches()) {
                response.addOrUpdateRemote(m.group(1), m.group(2), "fetch".equals(m.group(3)));
                return;
            }
        }
    }
}
